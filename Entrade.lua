-- "Бот для входа"" на языке Lua для Quik
-- Telegram @JJ_FXE 
-- https://napodrabotku.ru/order/48741304?region=all
---

--[[
Проверяем количество счетов (если == 1), то п.1 - 7
Если ~= 1, то получаем данные:
	- количество счетов
	- свободная сумма под открытие позиций
	- делим на количество счетов
	- получаем данные лотов для каждого счета = (90% * свободная_сумма) / ГО

1. Получаем данные инструмента
	вручную указываются:
		инструмент (код фьючерса)
		направление (buy/sell)
		время открытия позиции
		объем используемых средств (90% по умолчанию)
		временной лаг (15 сек по умолчанию)
		номера счетов (по которым будет торговля)
	
	из quik получаем:
		цена входа Ask или Bid
		стоимость портфеля – денежная оценка (таблица «Ограничения по клиентским счетам»
		ГО из таблицы текущих торгов

1.1 Получаем данные о позициях по инструменту
		если позиция в момент входа есть  - закрываем реверсом
		
		(В ситуации когда уже есть открытая позиция и необходимо зайти в противоположную, 
		бот должен автоматом закрывать текущую открытую и заходить в противоположную позицию. 
		Например, текущая позиция – +15 контрактов (покупка). 
		В 18:30 должна быть продажа на 90% от портфеля (допустим также -15 контрактов). 
		Тут бот должен продать не 15, а 30 контрактов +15 – 30 = -15 + это позиция на покупку, — это позиция на продажу.

2. Получаем данные стакана (цены ask и bid)
3. Покупаем лимитной заявкой по ask
	проверяем исполнение, если не полное, то:
4. Ждём 15 сек
5. Проверяем исполнение всей заявки, 
6. Если заявка выполнилась - ок, 
7. Если не выполнилась, получаем остаток, повторяем п.2 - 7

--]]

--[[
local pairs = pairs
local type = type

module(...)

--- Создать копию массива (таблицы)
-- @return копию массива (таблицы)
function copy(array)
    local copy_array = {}
    if type(array) ~= "table" then
        return array
    end
    for k, v in pairs(array) do
        if type(v) == "table" then
            copy_array[k] = copy(v)
        else
            copy_array[k] = v
        end
    end
    return copy_array
end

--- Узнать, начинается ли индексация в массиве с нуля или с единицы.
-- @return 0 или 1
function base(array)
    if array[0] ~= nil then
        return 0
    else
        return 1
    end
end

--- Вычислить число элементов в массиве.
-- @return число элементов в массиве
function size(array)
    local n = 0
    for _, _ in pairs(array) do
        n = n + 1
    end
    return n
end

--- Проверить пустой или нет массив.
-- @return true/false
function isEmpty(array)
    for _, _ in pairs(array) do
        return false
    end
    return true
end

--- Получить первый индекс массива, где ничего не записано. Поиск начинается с 1.
-- @return первый индекс массива, где ничего не записано
function firstEmptyIndex(array)
    local i = 1
    while array[i] ~= nil do
        i = i + 1
    end
    return i
end

--]]


nFile = ""              -- название создаваемого файла (по имени инструмента)
scName = ""             -- название запускаемого скрипта

function OnInit()
	    --инициализация
    scName = string.match(debug.getinfo(1).short_src, "\\([^\\]+)%.lua$") -- получение имени запущенного скрипта
    nFile = getScriptPath() .. "\\" .. scName .. ".csv"
end

function OnStop() -- действия при остановке скрипта
    -- if t_id ~= nil then
    --     DestroyTable(t_id)
    -- end
    is_run = false
end

function main()
    CreateTable() -- создаём таблицу
    SetTableNotificationCallback(t_id, f_cb) -- добавляем callback обработки

    while is_run do
        for i, _ in pairs(tInstr) do
            ds[i] = {}
            ds[i] = getNumCandles(tInstr[i][2])
            -- переделать через DataSource

                -- msg(ds[i] .. " количество свечей: " .. tInstr[i][2] .. ": i = " .. i) -- для проверки получения данных

            if ds[i] == 0 or ds[i] == nil then
                -- i = nil -- если tag не поставлен, убираем элемент массива
                msg("Не получено данных с графика.\nили нет метки " .. tostring(tInstr[i][2]) .. "\nГрафик инструмента " .. tostring(tInstr[i][1]) .. "\nОстановка")
                OnStop()
                return -- это для прерывания цикла на текущем моменте, а не в конце.
            end
            pse(SlTime)
            --[[
                msg(Classcode)
                msg(tInstr[i][1])
                msg(tInstr[i][3])
                msg (ds[i])
                msg("i = " .. i)
            --]]
        end

        if (IsWindowClosed(t_id)) then OnStop()
        end
    end
end



----
instrument = "BR-5.22" -- код фьючерса
direction = "buy" -- направление сделки (покупка)
entry_time = "18:30" -- время открытия позиции
order_volume = 0.9 -- объем средств, на который выставляется заявка (в % от текущей стоимости портфеля)
time_lag = 15 -- временной лаг (в секундах)
accounts = {"Счет 1", "Счет 2"} -- список счетов, по которым будут выставлены заявки

-- функция для получения текущей цены
function get_price()
-- здесь должен быть код для получения текущей цены инструмента
end

-- функция для выставления заявки
function place_order(account, volume, price)
    -- здесь должен быть код для выставления заявки на указанный счет
end

-- выставляем три заявки на покупку
for i = 1, 3 do
    price = get_price() -- получаем текущую цену
    order_price = price + 10 -- устанавливаем цену заявки на 10 пунктов выше текущей
    order_volume = order_volume / 3 -- делим объем заявки на три, чтобы выставить три заявки на одинаковый объем
    for j, account in ipairs(accounts) do
        place_order(account, order_volume, order_price) -- выставляем заявку на указанный счет
    end
    sleep(time_lag) -- ждем указанное время перед выставлением следующей заявки
end