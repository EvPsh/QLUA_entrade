-- "Бот для входа"" на языке Lua для Quik
-- Telegram @JJ_FXE 
-- https://napodrabotku.ru/order/48741304?region=all
---

--[[
Проверяем количество счетов (если == 1), то п.1 - 7
Если ~= 1, то получаем данные:
	- количество счетов
	- свободная сумма под открытие позиций
	- делим на количество счетов
	- получаем данные лотов для каждого счета = (90% * свободная_сумма) / ГО

1. Получаем данные инструмента
	вручную указываются:
		инструмент (код фьючерса)
		направление (buy/sell)
		время открытия позиции
		объем используемых средств (90% по умолчанию)
		временной лаг (15 сек по умолчанию)
		номера счетов (по которым будет торговля)
	
	из quik получаем:
		цена входа Ask или Bid
		стоимость портфеля – денежная оценка (таблица «Ограничения по клиентским счетам»
		ГО из таблицы текущих торгов

1.1 Получаем данные о позициях по инструменту
		если позиция в момент входа есть  - закрываем реверсом
		
		(В ситуации когда уже есть открытая позиция и необходимо зайти в противоположную, 
		бот должен автоматом закрывать текущую открытую и заходить в противоположную позицию. 
		Например, текущая позиция – +15 контрактов (покупка). 
		В 18:30 должна быть продажа на 90% от портфеля (допустим также -15 контрактов). 
		Тут бот должен продать не 15, а 30 контрактов +15 – 30 = -15 + это позиция на покупку, — это позиция на продажу.

2. Получаем данные стакана (цены ask и bid)
3. Покупаем лимитной заявкой по ask
	проверяем исполнение, если не полное, то:
4. Ждём 15 сек
5. Проверяем исполнение всей заявки, 
6. Если заявка выполнилась - ок, 
7. Если не выполнилась, получаем остаток, повторяем п.2 - 7

--]]

nFile = ""              -- название создаваемого файла (по имени инструмента)
scName = ""             -- название запускаемого скрипта

function OnInit()
	    --инициализация
    scName = string.match(debug.getinfo(1).short_src, "\\([^\\]+)%.lua$") -- получение имени запущенного скрипта
    nFile = getScriptPath() .. "\\" .. scName .. ".csv"
end

function OnStop() -- действия при остановке скрипта
    -- if t_id ~= nil then
    --     DestroyTable(t_id)
    -- end
    is_run = false
end

function main()
    CreateTable() -- создаём таблицу
    SetTableNotificationCallback(t_id, f_cb) -- добавляем callback обработки

    while is_run do
        for i, _ in pairs(tInstr) do
            ds[i] = {}
            ds[i] = getNumCandles(tInstr[i][2])
            -- переделать через DataSource

                -- msg(ds[i] .. " количество свечей: " .. tInstr[i][2] .. ": i = " .. i) -- для проверки получения данных

            if ds[i] == 0 or ds[i] == nil then
                -- i = nil -- если tag не поставлен, убираем элемент массива
                msg("Не получено данных с графика.\nили нет метки " .. tostring(tInstr[i][2]) .. "\nГрафик инструмента " .. tostring(tInstr[i][1]) .. "\nОстановка")
                OnStop()
                return -- это для прерывания цикла на текущем моменте, а не в конце.
            end
            pse(SlTime)
            --[[
                msg(Classcode)
                msg(tInstr[i][1])
                msg(tInstr[i][3])
                msg (ds[i])
                msg("i = " .. i)
            --]]
        end

        if (IsWindowClosed(t_id)) then OnStop()
        end
    end
end